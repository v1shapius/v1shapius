import asyncio
import logging
import discord
from datetime import datetime, timedelta
from typing import List, Optional, Tuple
from sqlalchemy import select, and_, or_
from database.database import DatabaseManager
from models.season import Season
from models.match import Match, MatchStatus
from models.player import Player

logger = logging.getLogger(__name__)

class SeasonManager:
    """Service for managing seasons and their lifecycle"""
    
    def __init__(self, bot):
        self.bot = bot
        self.db = DatabaseManager()
        self.check_interval = 3600  # Check every hour
        self.warning_threshold = 7  # Days before season end to start warnings
        
    async def start_monitoring(self):
        """Start the season monitoring loop"""
        logger.info("Starting season monitoring service")
        while True:
            try:
                await self.check_season_status()
                await asyncio.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"Error in season monitoring: {e}")
                await asyncio.sleep(60)  # Wait 1 minute on error
    
    async def check_season_status(self):
        """Check and update season status"""
        try:
            session = await self.db.get_session()
        async with session:
                # Get current active season
                current_season = await session.execute(
                    select(Season).where(Season.is_active == True)
                )
                current_season = current_season.scalar_one_or_none()
                
                if not current_season:
                    logger.info("No active season found")
                    return
                
                # Check if season is ending soon
                if current_season.is_ending_soon and not current_season.season_end_warning_sent:
                    await self.send_season_end_warnings(session, current_season)
                    current_season.season_end_warning_sent = True
                
                # Check if season should be marked as ending
                if current_season.days_until_end <= self.warning_threshold and not current_season.is_ending:
                    await self.mark_season_as_ending(session, current_season)
                
                # Check if season should end
                if current_season.days_until_end <= 0:
                    await self.end_season(session, current_season)
                
                await session.commit()
                
        except Exception as e:
            logger.error(f"Error checking season status: {e}")
    
    async def send_season_end_warnings(self, session, season: Season):
        """Send warnings to players with active matches"""
        try:
            # Get all active matches
            active_matches = await session.execute(
                select(Match).where(
                    and_(
                        Match.status.in_([
                            MatchStatus.WAITING_PLAYERS,
                            MatchStatus.WAITING_READINESS,
                            MatchStatus.DRAFT_VERIFICATION,
                            MatchStatus.FIRST_PLAYER_SELECTION,
                            MatchStatus.GAME_PREPARATION,
                            MatchStatus.GAME_IN_PROGRESS,
                            MatchStatus.RESULT_CONFIRMATION
                        ]),
                        Match.season_id == season.id
                    )
                )
            )
            active_matches = active_matches.fetchall()
            
            if not active_matches:
                logger.info("No active matches to warn about season end")
                return
            
            # Get unique player IDs from active matches
            player_ids = set()
            for match in active_matches:
                if match.player1_id:
                    player_ids.add(match.player1_id)
                if match.player2_id:
                    player_ids.add(match.player2_id)
            
            # Get player Discord IDs
            players = await session.execute(
                select(Player).where(Player.id.in_(list(player_ids)))
            )
            players = players.fetchall()
            
            # Send warnings to each player
            for player in players:
                await self.send_player_warning(player.discord_id, season)
            
            logger.info(f"Sent season end warnings to {len(players)} players")
            
            # Send guild notification with role tagging
            if hasattr(self.bot, 'role_manager'):
                guild_id = await self.get_guild_id_for_season(session, season)
                if guild_id:
                    tagged_message = await self.bot.role_manager.tag_role_for_event(
                        guild_id=guild_id,
                        event_type="season_end",
                        message="üö® **–í–Ω–∏–º–∞–Ω–∏–µ! –°–µ–∑–æ–Ω –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è** - –ó–∞–≤–µ—Ä—à–∏—Ç–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ç—á–∏!"
                    )
                    
                    # Send to guild's system channel or first available channel
                    guild = self.bot.get_guild(guild_id)
                    if guild:
                        channel = guild.system_channel or guild.text_channels[0] if guild.text_channels else None
                        if channel:
                            try:
                                await channel.send(tagged_message)
                            except discord.Forbidden:
                                logger.warning(f"Could not send season end warning to guild {guild_id}")
            
        except Exception as e:
            logger.error(f"Error sending season end warnings: {e}")
    
    async def get_guild_id_for_season(self, session, season) -> Optional[int]:
        """Get guild ID for a season"""
        try:
            # This is a placeholder - you'll need to implement based on your data structure
            # For now, return None to avoid errors
            return None
        except Exception as e:
            logger.error(f"Error getting guild ID for season: {e}")
            return None
    
    async def send_player_warning(self, discord_id: int, season: Season):
        """Send season end warning to a specific player"""
        try:
            user = self.bot.get_user(discord_id)
            if not user:
                logger.warning(f"Could not find user {discord_id} for season warning")
                return
            
            embed = self.create_season_end_warning_embed(season)
            
            try:
                await user.send(
                    "üö® **–í–Ω–∏–º–∞–Ω–∏–µ! –°–µ–∑–æ–Ω —Å–∫–æ—Ä–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è**\n\n"
                    "–£ –≤–∞—Å –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ç—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω—ã –¥–æ –æ–∫–æ–Ω—á–∞–Ω–∏—è —Å–µ–∑–æ–Ω–∞.",
                    embed=embed
                )
            except discord.Forbidden:
                logger.warning(f"Could not send DM to user {discord_id}")
                
        except Exception as e:
            logger.error(f"Error sending player warning: {e}")
    
    def create_season_end_warning_embed(self, season: Season) -> discord.Embed:
        """Create embed for season end warning"""
        embed = discord.Embed(
            title="üö® –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–µ–∑–æ–Ω–∞",
            description="–°–µ–∑–æ–Ω —Å–∫–æ—Ä–æ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è!",
            color=discord.Color.orange()
        )
        
        embed.add_field(
            name="–°–µ–∑–æ–Ω",
            value=season.name,
            inline=True
        )
        
        embed.add_field(
            name="–î–Ω–µ–π –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è",
            value=f"**{season.days_until_end}**",
            inline=True
        )
        
        embed.add_field(
            name="–°—Ç–∞—Ç—É—Å",
            value=season.get_status_description(),
            inline=True
        )
        
        embed.add_field(
            name="‚ö†Ô∏è –í–∞–∂–Ω–æ",
            value="–ó–∞–≤–µ—Ä—à–∏—Ç–µ –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ç—á–∏ –¥–æ –æ–∫–æ–Ω—á–∞–Ω–∏—è —Å–µ–∑–æ–Ω–∞, –∏–Ω–∞—á–µ –æ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –∞–Ω–Ω—É–ª–∏—Ä–æ–≤–∞–Ω—ã.",
            inline=False
        )
        
        embed.add_field(
            name="‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
            value="–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ–∑–æ–Ω–∞:\n‚Ä¢ –ù–æ–≤—ã–µ –º–∞—Ç—á–∏ –±—É–¥—É—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã\n‚Ä¢ –†–µ–π—Ç–∏–Ω–≥ –±—É–¥–µ—Ç –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω\n‚Ä¢ –ù–∞—á–Ω–µ—Ç—Å—è –Ω–æ–≤—ã–π —Å–µ–∑–æ–Ω",
            inline=False
        )
        
        embed.set_footer(text="–°–µ–∑–æ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –ø–æ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏")
        
        return embed
    
    async def mark_season_as_ending(self, session, season: Season):
        """Mark season as ending and block new matches"""
        try:
            season.mark_as_ending()
            season.block_new_matches()
            
            logger.info(f"Season {season.name} marked as ending")
            
            # Send notification to all guilds using this season
            await self.notify_guilds_season_ending(season)
            
        except Exception as e:
            logger.error(f"Error marking season as ending: {e}")
    
    async def notify_guilds_season_ending(self, season: Season):
        """Notify all guilds that season is ending"""
        try:
            # Get unique guild IDs from matches in this season
            session = await self.db.get_session()
        async with session:
                guilds = await session.execute(
                    select(Match.guild_id).where(
                        and_(
                            Match.season_id == season.id,
                            Match.guild_id.isnot(None)
                        )
                    ).distinct()
                )
                guilds = guilds.fetchall()
                
                for guild_row in guilds:
                    guild_id = guild_row[0]
                    await self.notify_guild_season_ending(guild_id, season)
                    
        except Exception as e:
            logger.error(f"Error notifying guilds about season ending: {e}")
    
    async def notify_guild_season_ending(self, guild_id: int, season: Season):
        """Notify a specific guild that season is ending"""
        try:
            guild = self.bot.get_guild(guild_id)
            if not guild:
                return
            
            # Try to find audit channel
            session = await self.db.get_session()
        async with session:
                penalty_settings = await session.execute(
                    "SELECT audit_channel_id FROM penalty_settings WHERE guild_id = :guild_id",
                    {"guild_id": guild_id}
                )
                penalty_settings = penalty_settings.scalar_one_or_none()
                
                audit_channel_id = penalty_settings.audit_channel_id if penalty_settings else None
                
                if audit_channel_id:
                    channel = guild.get_channel(audit_channel_id)
                    if channel:
                        embed = self.create_guild_season_ending_embed(season)
                        await channel.send(
                            "üö® **–í–Ω–∏–º–∞–Ω–∏–µ! –°–µ–∑–æ–Ω —Å–∫–æ—Ä–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è**",
                            embed=embed
                        )
                        
        except Exception as e:
            logger.error(f"Error notifying guild {guild_id}: {e}")
    
    def create_guild_season_ending_embed(self, season: Season) -> discord.Embed:
        """Create embed for guild season ending notification"""
        embed = discord.Embed(
            title="üö® –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–µ–∑–æ–Ω–∞",
            description="–°–µ–∑–æ–Ω —Å–∫–æ—Ä–æ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è!",
            color=discord.Color.orange()
        )
        
        embed.add_field(
            name="–°–µ–∑–æ–Ω",
            value=season.name,
            inline=True
        )
        
        embed.add_field(
            name="–î–Ω–µ–π –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è",
            value=f"**{season.days_until_end}**",
            inline=True
        )
        
        embed.add_field(
            name="–°—Ç–∞—Ç—É—Å",
            value=season.get_status_description(),
            inline=True
        )
        
        embed.add_field(
            name="üìã –î–µ–π—Å—Ç–≤–∏—è",
            value="‚Ä¢ –ù–æ–≤—ã–µ –º–∞—Ç—á–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã\n‚Ä¢ –ó–∞–≤–µ—Ä—à–∏—Ç–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ç—á–∏\n‚Ä¢ –†–µ–π—Ç–∏–Ω–≥ –±—É–¥–µ—Ç –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω",
            inline=False
        )
        
        embed.set_footer(text="–°–µ–∑–æ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –ø–æ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏")
        
        return embed
    
    async def end_season(self, session, season: Season):
        """End the season and handle cleanup"""
        try:
            # Check if there are still active matches
            active_matches = await session.execute(
                select(Match).where(
                    and_(
                        Match.season_id == season.id,
                        Match.status.in_([
                            MatchStatus.WAITING_PLAYERS,
                            MatchStatus.WAITING_READINESS,
                            MatchStatus.DRAFT_VERIFICATION,
                            MatchStatus.FIRST_PLAYER_SELECTION,
                            MatchStatus.GAME_PREPARATION,
                            MatchStatus.GAME_IN_PROGRESS,
                            MatchStatus.RESULT_CONFIRMATION
                        ])
                    )
                )
            )
            active_matches = active_matches.fetchall()
            
            if active_matches:
                # Force end active matches
                for match in active_matches:
                    match.status = MatchStatus.ANNULLED
                    match.annulment_reason = "–°–µ–∑–æ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏"
                
                logger.info(f"Force ended {len(active_matches)} active matches due to season end")
            
            # End the season
            season.end_season()
            
            logger.info(f"Season {season.name} ended successfully")
            
            # Notify guilds about season end
            await self.notify_guilds_season_ended(season)
            
        except Exception as e:
            logger.error(f"Error ending season: {e}")
    
    async def notify_guilds_season_ended(self, season: Season):
        """Notify all guilds that season has ended"""
        try:
            # Get unique guild IDs from matches in this season
            session = await self.db.get_session()
        async with session:
                guilds = await session.execute(
                    select(Match.guild_id).where(
                        and_(
                            Match.season_id == season.id,
                            Match.guild_id.isnot(None)
                        )
                    ).distinct()
                )
                guilds = guilds.fetchall()
                
                for guild_row in guilds:
                    guild_id = guild_row[0]
                    await self.notify_guild_season_ended(guild_id, season)
                    
        except Exception as e:
            logger.error(f"Error notifying guilds about season end: {e}")
    
    async def notify_guild_season_ended(self, guild_id: int, season: Season):
        """Notify a specific guild that season has ended"""
        try:
            guild = self.bot.get_guild(guild_id)
            if not guild:
                return
            
            # Try to find audit channel
            session = await self.db.get_session()
        async with session:
                penalty_settings = await session.execute(
                    "SELECT audit_channel_id FROM penalty_settings WHERE guild_id = :guild_id",
                    {"guild_id": guild_id}
                )
                penalty_settings = penalty_settings.scalar_one_or_none()
                
                audit_channel_id = penalty_settings.audit_channel_id if penalty_settings else None
                
                if audit_channel_id:
                    channel = guild.get_channel(audit_channel_id)
                    if channel:
                        embed = self.create_guild_season_ended_embed(season)
                        await channel.send(
                            "üèÅ **–°–µ–∑–æ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω!**",
                            embed=embed
                        )
                        
        except Exception as e:
            logger.error(f"Error notifying guild {guild_id}: {e}")
    
    def create_guild_season_ended_embed(self, season: Season) -> discord.Embed:
        """Create embed for guild season ended notification"""
        embed = discord.Embed(
            title="üèÅ –°–µ–∑–æ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω",
            description="–°–µ–∑–æ–Ω —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω!",
            color=discord.Color.green()
        )
        
        embed.add_field(
            name="–°–µ–∑–æ–Ω",
            value=season.name,
            inline=True
        )
        
        embed.add_field(
            name="–î–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è",
            value=season.end_date.strftime("%d.%m.%Y %H:%M"),
            inline=True
        )
        
        embed.add_field(
            name="–°—Ç–∞—Ç—É—Å",
            value="–ó–∞–≤–µ—Ä—à–µ–Ω",
            inline=True
        )
        
        embed.add_field(
            name="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã",
            value="‚Ä¢ –†–µ–π—Ç–∏–Ω–≥ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω\n‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞\n‚Ä¢ –ù–æ–≤—ã–π —Å–µ–∑–æ–Ω —Å–∫–æ—Ä–æ –Ω–∞—á–Ω–µ—Ç—Å—è",
            inline=False
        )
        
        embed.set_footer(text="–°–ø–∞—Å–∏–±–æ –∑–∞ —É—á–∞—Å—Ç–∏–µ –≤ —Å–µ–∑–æ–Ω–µ!")
        
        return embed
    
    async def can_create_new_match(self, guild_id: int) -> Tuple[bool, str]:
        """Check if new matches can be created in a guild"""
        try:
            session = await self.db.get_session()
        async with session:
                # Get current active season
                current_season = await session.execute(
                    select(Season).where(Season.is_active == True)
                )
                current_season = current_season.scalar_one_or_none()
                
                if not current_season:
                    return False, "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–µ–∑–æ–Ω–∞"
                
                if current_season.should_block_new_matches:
                    return False, current_season.get_blocking_reason()
                
                return True, "–ù–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π"
                
        except Exception as e:
            logger.error(f"Error checking if new matches can be created: {e}")
            return False, "–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏"
    
    async def get_season_status(self, guild_id: int) -> Optional[Season]:
        """Get current season status for a guild"""
        try:
            session = await self.db.get_session()
        async with session:
                current_season = await session.execute(
                    select(Season).where(Season.is_active == True)
                )
                return current_season.scalar_one_or_none()
                
        except Exception as e:
            logger.error(f"Error getting season status: {e}")
            return None